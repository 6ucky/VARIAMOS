/* !---- DO NOT EDIT: This file autogenerated by com\jogamp\gluegen\JavaEmitter.java on Thu Mar 28 11:31:34 CET 2013 ----! */

package com.cfm.jgprolog.gnuprolog;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;

import com.jogamp.common.nio.Buffers;
import com.jogamp.common.nio.PointerBuffer;

public class JGProlog {

  /** Defined as part of enum type "PlBool" */
  public static final int PL_FALSE = 0;
  /** Defined as part of enum type "PlBool" */
  public static final int PL_TRUE = 1;
  public static final int __GNU_PROLOG__ = 1;
  public static final int __GPROLOG__ = 1;
  public static final int __GPROLOG_MINOR__ = 4;
  public static final int __GPROLOG_PATCHLEVEL__ = 3;
  public static final int __GPROLOG_VERSION__ = 10403;
  public static final int PL_MIN_INTEGER = -268435456;
  public static final int PL_MAX_INTEGER = 268435455;
  public static final int PL_REF = 0;
  public static final int PL_LST = 1;
  public static final int PL_STC = 2;
  public static final int PL_ATM = 3;
  public static final int PL_FLT = 4;
  public static final int PL_FDV = 5;
  public static final int PL_INT = 7;
  public static final int PL_RECOVER = 0;
  public static final int PL_CUT = 1;
  public static final int PL_KEEP_FOR_PROLOG = 2;
  public static final int PL_FAILURE = 0;
  public static final int PL_SUCCESS = 1;
  public static final int PL_EXCEPTION = 2;
  public static final int PL_PLV = 0;

  /** Interface to C language function: <br> <code> int Pl_Atom_Char(char c); </code>    */
  public static native int Pl_Atom_Char(byte c);

  /** Interface to C language function: <br> <code> int Pl_Atom_End_Of_File(void); </code>    */
  public static native int Pl_Atom_End_Of_File();

  /** Interface to C language function: <br> <code> int Pl_Atom_False(void); </code>    */
  public static native int Pl_Atom_False();

  /** Interface to C language function: <br> <code> int Pl_Atom_Length(int atom); </code>    */
  public static native int Pl_Atom_Length(int atom);

  /** Interface to C language function: <br> <code> char *  Pl_Atom_Name(int atom); </code>    */
  public static native String Pl_Atom_Name(int atom);

  /** Interface to C language function: <br> <code> PlBool Pl_Atom_Needs_Quote(int atom); </code>    */
  public static native boolean Pl_Atom_Needs_Quote(int atom);

  /** Interface to C language function: <br> <code> PlBool Pl_Atom_Needs_Scan(int atom); </code>    */
  public static native boolean Pl_Atom_Needs_Scan(int atom);

  /** Interface to C language function: <br> <code> int Pl_Atom_Nil(void); </code>    */
  public static native int Pl_Atom_Nil();

  /** Interface to C language function: <br> <code> int Pl_Atom_True(void); </code>    */
  public static native int Pl_Atom_True();

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Arg(PlTerm arg_no, PlTerm term, PlTerm sub_term); </code>    */
  public static native boolean Pl_Builtin_Arg(long arg_no, long term, long sub_term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Atom(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Atom(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Atomic(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Atomic(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Callable(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Callable(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Compare(PlTerm cmp, PlTerm term1, PlTerm term2); </code>    */
  public static native boolean Pl_Builtin_Compare(long cmp, long term1, long term2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Compound(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Compound(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Eq(PlTerm expr1, PlTerm expr2); </code>    */
  public static native boolean Pl_Builtin_Eq(long expr1, long expr2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Fd_Var(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Fd_Var(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Float(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Float(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Functor(PlTerm term, PlTerm functor, PlTerm arity); </code>    */
  public static native boolean Pl_Builtin_Functor(long term, long functor, long arity);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Generic_Var(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Generic_Var(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Gt(PlTerm expr1, PlTerm expr2); </code>    */
  public static native boolean Pl_Builtin_Gt(long expr1, long expr2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Gte(PlTerm expr1, PlTerm expr2); </code>    */
  public static native boolean Pl_Builtin_Gte(long expr1, long expr2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Integer(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Integer(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_List(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_List(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_List_Or_Partial_List(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_List_Or_Partial_List(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Lt(PlTerm expr1, PlTerm expr2); </code>    */
  public static native boolean Pl_Builtin_Lt(long expr1, long expr2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Lte(PlTerm expr1, PlTerm expr2); </code>    */
  public static native boolean Pl_Builtin_Lte(long expr1, long expr2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Neq(PlTerm expr1, PlTerm expr2); </code>    */
  public static native boolean Pl_Builtin_Neq(long expr1, long expr2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Non_Fd_Var(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Non_Fd_Var(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Non_Generic_Var(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Non_Generic_Var(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Non_Var(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Non_Var(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Number(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Number(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Partial_List(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Partial_List(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Term_Eq(PlTerm term1, PlTerm term2); </code>    */
  public static native boolean Pl_Builtin_Term_Eq(long term1, long term2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Term_Gt(PlTerm term1, PlTerm term2); </code>    */
  public static native boolean Pl_Builtin_Term_Gt(long term1, long term2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Term_Gte(PlTerm term1, PlTerm term2); </code>    */
  public static native boolean Pl_Builtin_Term_Gte(long term1, long term2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Term_Lt(PlTerm term1, PlTerm term2); </code>    */
  public static native boolean Pl_Builtin_Term_Lt(long term1, long term2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Term_Lte(PlTerm term1, PlTerm term2); </code>    */
  public static native boolean Pl_Builtin_Term_Lte(long term1, long term2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Term_Neq(PlTerm term1, PlTerm term2); </code>    */
  public static native boolean Pl_Builtin_Term_Neq(long term1, long term2);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Univ(PlTerm term, PlTerm list); </code>    */
  public static native boolean Pl_Builtin_Univ(long term, long list);

  /** Interface to C language function: <br> <code> PlBool Pl_Builtin_Var(PlTerm term); </code>    */
  public static native boolean Pl_Builtin_Var(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Atom(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Atom(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Boolean(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Boolean(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Byte(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Byte(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Callable(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Callable(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Char(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Char(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Chars(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Chars(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Code(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Code(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Codes(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Codes(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Compound(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Compound(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Float(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Float(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_In_Byte(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_In_Byte(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_In_Char(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_In_Char(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_In_Code(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_In_Code(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Integer(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Integer(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_List(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_List(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Number(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Number(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Positive(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Positive(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_String(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_String(long term);

  /** Interface to C language function: <br> <code> void Pl_Check_For_Un_Variable(PlTerm term); </code>    */
  public static native void Pl_Check_For_Un_Variable(long term);

  /** Interface to C language function: <br> <code> void Pl_Copy_Contiguous_Term(PlTerm *  dst_term, PlTerm *  src_term); </code> 
      @param dst_term a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param src_term a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static void Pl_Copy_Contiguous_Term(PointerBuffer dst_term, PointerBuffer src_term)  {

    final boolean dst_term_is_direct = Buffers.isDirect(dst_term);
    final boolean src_term_is_direct = Buffers.isDirect(src_term);
        Pl_Copy_Contiguous_Term1(dst_term_is_direct ? ( dst_term != null ? dst_term.getBuffer() : null ) : Buffers.getArray(dst_term), dst_term_is_direct ? Buffers.getDirectBufferByteOffset(dst_term) : Buffers.getIndirectBufferByteOffset(dst_term), dst_term_is_direct, src_term_is_direct ? ( src_term != null ? src_term.getBuffer() : null ) : Buffers.getArray(src_term), src_term_is_direct ? Buffers.getDirectBufferByteOffset(src_term) : Buffers.getIndirectBufferByteOffset(src_term), src_term_is_direct);
  }

  /** Entry point to C language function: <code> void Pl_Copy_Contiguous_Term(PlTerm *  dst_term, PlTerm *  src_term); </code> 
      @param dst_term a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param src_term a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native void Pl_Copy_Contiguous_Term1(Object dst_term, int dst_term_byte_offset, boolean dst_term_is_direct, Object src_term, int src_term_byte_offset, boolean src_term_is_direct);

  /** Interface to C language function: <br> <code> void Pl_Copy_Term(PlTerm *  dst_term, PlTerm *  src_term); </code> 
      @param dst_term a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param src_term a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static void Pl_Copy_Term(PointerBuffer dst_term, PointerBuffer src_term)  {

    final boolean dst_term_is_direct = Buffers.isDirect(dst_term);
    final boolean src_term_is_direct = Buffers.isDirect(src_term);
        Pl_Copy_Term1(dst_term_is_direct ? ( dst_term != null ? dst_term.getBuffer() : null ) : Buffers.getArray(dst_term), dst_term_is_direct ? Buffers.getDirectBufferByteOffset(dst_term) : Buffers.getIndirectBufferByteOffset(dst_term), dst_term_is_direct, src_term_is_direct ? ( src_term != null ? src_term.getBuffer() : null ) : Buffers.getArray(src_term), src_term_is_direct ? Buffers.getDirectBufferByteOffset(src_term) : Buffers.getIndirectBufferByteOffset(src_term), src_term_is_direct);
  }

  /** Entry point to C language function: <code> void Pl_Copy_Term(PlTerm *  dst_term, PlTerm *  src_term); </code> 
      @param dst_term a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param src_term a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native void Pl_Copy_Term1(Object dst_term, int dst_term_byte_offset, boolean dst_term_is_direct, Object src_term, int src_term_byte_offset, boolean src_term_is_direct);

  /** Interface to C language function: <br> <code> int Pl_Create_Allocate_Atom(const char *  atom); </code>    */
  public static native int Pl_Create_Allocate_Atom(String atom);

  /** Interface to C language function: <br> <code> int Pl_Create_Atom(const char *  atom); </code>    */
  public static native int Pl_Create_Atom(String atom);

  /** Interface to C language function: <br> <code> char *  Pl_Display_To_String(PlTerm term); </code>    */
  public static native String Pl_Display_To_String(long term);

  /** Interface to C language function: <br> <code> void Pl_Emit_Syntax_Error(char *  file_name, int err_line, int err_col, char *  err_msg); </code> 
      @param err_msg a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static void Pl_Emit_Syntax_Error(String file_name, int err_line, int err_col, ByteBuffer err_msg)  {

    final boolean err_msg_is_direct = Buffers.isDirect(err_msg);
        Pl_Emit_Syntax_Error1(file_name, err_line, err_col, err_msg_is_direct ? err_msg : Buffers.getArray(err_msg), err_msg_is_direct ? Buffers.getDirectBufferByteOffset(err_msg) : Buffers.getIndirectBufferByteOffset(err_msg), err_msg_is_direct);
  }

  /** Entry point to C language function: <code> void Pl_Emit_Syntax_Error(char *  file_name, int err_line, int err_col, char *  err_msg); </code> 
      @param err_msg a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native void Pl_Emit_Syntax_Error1(String file_name, int err_line, int err_col, Object err_msg, int err_msg_byte_offset, boolean err_msg_is_direct);

  /** Interface to C language function: <br> <code> void Pl_Emit_Syntax_Error(char *  file_name, int err_line, int err_col, char *  err_msg); </code>    */
  public static void Pl_Emit_Syntax_Error(String file_name, int err_line, int err_col, byte[] err_msg, int err_msg_offset)  {

    if(err_msg != null && err_msg.length <= err_msg_offset)
      throw new RuntimeException("array offset argument \"err_msg_offset\" (" + err_msg_offset + ") equals or exceeds array length (" + err_msg.length + ")");
        Pl_Emit_Syntax_Error1(file_name, err_line, err_col, err_msg, err_msg_offset, false);
  }

  /** Interface to C language function: <br> <code> void Pl_Err_Domain(int atom_domain, PlTerm term); </code>    */
  public static native void Pl_Err_Domain(int atom_domain, long term);

  /** Interface to C language function: <br> <code> void Pl_Err_Evaluation(int pl_atom_error); </code>    */
  public static native void Pl_Err_Evaluation(int pl_atom_error);

  /** Interface to C language function: <br> <code> void Pl_Err_Existence(int atom_object, PlTerm term); </code>    */
  public static native void Pl_Err_Existence(int atom_object, long term);

  /** Interface to C language function: <br> <code> void Pl_Err_Instantiation(void); </code>    */
  public static native void Pl_Err_Instantiation();

  /** Interface to C language function: <br> <code> void Pl_Err_Permission(int atom_oper, int atom_perm, PlTerm term); </code>    */
  public static native void Pl_Err_Permission(int atom_oper, int atom_perm, long term);

  /** Interface to C language function: <br> <code> void Pl_Err_Representation(int atom_flag); </code>    */
  public static native void Pl_Err_Representation(int atom_flag);

  /** Interface to C language function: <br> <code> void Pl_Err_Resource(int atom_resource); </code>    */
  public static native void Pl_Err_Resource(int atom_resource);

  /** Interface to C language function: <br> <code> void Pl_Err_Syntax(int pl_atom_error); </code>    */
  public static native void Pl_Err_Syntax(int pl_atom_error);

  /** Interface to C language function: <br> <code> void Pl_Err_System(int pl_atom_error); </code>    */
  public static native void Pl_Err_System(int pl_atom_error);

  /** Interface to C language function: <br> <code> void Pl_Err_Type(int atom_type, PlTerm term); </code>    */
  public static native void Pl_Err_Type(int atom_type, long term);

  /** Interface to C language function: <br> <code> void Pl_Exec_Continuation(int func, int arity, PlTerm *  arg_adr); </code> 
      @param arg_adr a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static void Pl_Exec_Continuation(int func, int arity, PointerBuffer arg_adr)  {

    final boolean arg_adr_is_direct = Buffers.isDirect(arg_adr);
        Pl_Exec_Continuation1(func, arity, arg_adr_is_direct ? ( arg_adr != null ? arg_adr.getBuffer() : null ) : Buffers.getArray(arg_adr), arg_adr_is_direct ? Buffers.getDirectBufferByteOffset(arg_adr) : Buffers.getIndirectBufferByteOffset(arg_adr), arg_adr_is_direct);
  }

  /** Entry point to C language function: <code> void Pl_Exec_Continuation(int func, int arity, PlTerm *  arg_adr); </code> 
      @param arg_adr a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native void Pl_Exec_Continuation1(int func, int arity, Object arg_adr, int arg_adr_byte_offset, boolean arg_adr_is_direct);

  /** Interface to C language function: <br> <code> int Pl_Find_Atom(const char *  atom); </code>    */
  public static native int Pl_Find_Atom(String atom);

  /** Interface to C language function: <br> <code> PlTerm Pl_Get_Exception(void); </code>    */
  public static native long Pl_Get_Exception();

  /** Interface to C language function: <br> <code> PlBool Pl_Is_Valid_Atom(int atom); </code>    */
  public static native boolean Pl_Is_Valid_Atom(int atom);

  /** Interface to C language function: <br> <code> int Pl_List_Length(PlTerm list); </code>    */
  public static native int Pl_List_Length(long list);

  /** Interface to C language function: <br> <code> void Pl_Math_Evaluate(PlTerm expr, PlTerm *  result); </code> 
      @param result a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static void Pl_Math_Evaluate(long expr, PointerBuffer result)  {

    final boolean result_is_direct = Buffers.isDirect(result);
        Pl_Math_Evaluate1(expr, result_is_direct ? ( result != null ? result.getBuffer() : null ) : Buffers.getArray(result), result_is_direct ? Buffers.getDirectBufferByteOffset(result) : Buffers.getIndirectBufferByteOffset(result), result_is_direct);
  }

  /** Entry point to C language function: <code> void Pl_Math_Evaluate(PlTerm expr, PlTerm *  result); </code> 
      @param result a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native void Pl_Math_Evaluate1(long expr, Object result, int result_byte_offset, boolean result_is_direct);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Atom(int value); </code>    */
  public static native long Pl_Mk_Atom(int value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Boolean(int value); </code>    */
  public static native long Pl_Mk_Boolean(int value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Byte(int value); </code>    */
  public static native long Pl_Mk_Byte(int value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Callable(int func, int arity, const PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long Pl_Mk_Callable(int func, int arity, PointerBuffer arg)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Mk_Callable1(func, arity, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct);
  }

  /** Entry point to C language function: <code> PlTerm Pl_Mk_Callable(int func, int arity, const PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long Pl_Mk_Callable1(int func, int arity, Object arg, int arg_byte_offset, boolean arg_is_direct);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Char(int value); </code>    */
  public static native long Pl_Mk_Char(int value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Chars(const char *  value); </code>    */
  public static native long Pl_Mk_Chars(String value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Code(int value); </code>    */
  public static native long Pl_Mk_Code(int value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Codes(const char *  value); </code>    */
  public static native long Pl_Mk_Codes(String value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Compound(int func, int arity, const PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long Pl_Mk_Compound(int func, int arity, PointerBuffer arg)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Mk_Compound1(func, arity, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct);
  }

  /** Entry point to C language function: <code> PlTerm Pl_Mk_Compound(int func, int arity, const PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long Pl_Mk_Compound1(int func, int arity, Object arg, int arg_byte_offset, boolean arg_is_direct);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Float(double value); </code>    */
  public static native long Pl_Mk_Float(double value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_In_Byte(int value); </code>    */
  public static native long Pl_Mk_In_Byte(int value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_In_Char(int value); </code>    */
  public static native long Pl_Mk_In_Char(int value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_In_Code(int value); </code>    */
  public static native long Pl_Mk_In_Code(int value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Integer(PlLong value); </code>    */
  public static native long Pl_Mk_Integer(long value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_List(const PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long Pl_Mk_List(PointerBuffer arg)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Mk_List1(arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct);
  }

  /** Entry point to C language function: <code> PlTerm Pl_Mk_List(const PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long Pl_Mk_List1(Object arg, int arg_byte_offset, boolean arg_is_direct);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Number(double value); </code>    */
  public static native long Pl_Mk_Number(double value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Positive(PlLong value); </code>    */
  public static native long Pl_Mk_Positive(long value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Proper_List(int n, const PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static long Pl_Mk_Proper_List(int n, PointerBuffer arg)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Mk_Proper_List1(n, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct);
  }

  /** Entry point to C language function: <code> PlTerm Pl_Mk_Proper_List(int n, const PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native long Pl_Mk_Proper_List1(int n, Object arg, int arg_byte_offset, boolean arg_is_direct);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_String(const char *  value); </code>    */
  public static native long Pl_Mk_String(String value);

  /** Interface to C language function: <br> <code> PlTerm Pl_Mk_Variable(void); </code>    */
  public static native long Pl_Mk_Variable();

  /** Interface to C language function: <br> <code> void Pl_No_More_Choice(void); </code>    */
  public static native void Pl_No_More_Choice();

  /** Interface to C language function: <br> <code> void Pl_Os_Error(void); </code>    */
  public static native void Pl_Os_Error();

  /** Interface to C language function: <br> <code> void Pl_Query_Begin(PlBool recoverable); </code> 
      @param recoverable valid values are: <code>PL_FALSE, PL_TRUE</code>
   */
  public static native void Pl_Query_Begin(boolean recoverable);

  /** Interface to C language function: <br> <code> int Pl_Query_Call(int func, int arity, PlTerm *  arg_adr); </code> 
      @param arg_adr a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static int Pl_Query_Call(int func, int arity, PointerBuffer arg_adr)  {

    final boolean arg_adr_is_direct = Buffers.isDirect(arg_adr);
        return Pl_Query_Call1(func, arity, arg_adr_is_direct ? ( arg_adr != null ? arg_adr.getBuffer() : null ) : Buffers.getArray(arg_adr), arg_adr_is_direct ? Buffers.getDirectBufferByteOffset(arg_adr) : Buffers.getIndirectBufferByteOffset(arg_adr), arg_adr_is_direct);
  }

  /** Entry point to C language function: <code> int Pl_Query_Call(int func, int arity, PlTerm *  arg_adr); </code> 
      @param arg_adr a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native int Pl_Query_Call1(int func, int arity, Object arg_adr, int arg_adr_byte_offset, boolean arg_adr_is_direct);

  /** Interface to C language function: <br> <code> void Pl_Query_End(int op); </code>    */
  public static native void Pl_Query_End(int op);

  /** Interface to C language function: <br> <code> int Pl_Query_Next_Solution(void); </code>    */
  public static native int Pl_Query_Next_Solution();

  /** Interface to C language function: <br> <code> int Pl_Query_Start(int func, int arity, PlTerm *  arg_adr, PlBool recoverable); </code> 
      @param arg_adr a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param recoverable valid values are: <code>PL_FALSE, PL_TRUE</code>
   */
  public static int Pl_Query_Start(int func, int arity, PointerBuffer arg_adr, boolean recoverable)  {

    final boolean arg_adr_is_direct = Buffers.isDirect(arg_adr);
        return Pl_Query_Start1(func, arity, arg_adr_is_direct ? ( arg_adr != null ? arg_adr.getBuffer() : null ) : Buffers.getArray(arg_adr), arg_adr_is_direct ? Buffers.getDirectBufferByteOffset(arg_adr) : Buffers.getIndirectBufferByteOffset(arg_adr), arg_adr_is_direct, recoverable);
  }

  /** Entry point to C language function: <code> int Pl_Query_Start(int func, int arity, PlTerm *  arg_adr, PlBool recoverable); </code> 
      @param arg_adr a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}
      @param recoverable valid values are: <code>PL_FALSE, PL_TRUE</code>
   */
  private static native int Pl_Query_Start1(int func, int arity, Object arg_adr, int arg_adr_byte_offset, boolean arg_adr_is_direct, boolean recoverable);

  /** Interface to C language function: <br> <code> int Pl_Rd_Atom(PlTerm term); </code>    */
  public static native int Pl_Rd_Atom(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_Atom_Check(PlTerm term); </code>    */
  public static native int Pl_Rd_Atom_Check(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_Boolean(PlTerm term); </code>    */
  public static native int Pl_Rd_Boolean(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_Boolean_Check(PlTerm term); </code>    */
  public static native int Pl_Rd_Boolean_Check(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_Byte(PlTerm term); </code>    */
  public static native int Pl_Rd_Byte(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_Byte_Check(PlTerm term); </code>    */
  public static native int Pl_Rd_Byte_Check(long term);

  /** Interface to C language function: <br> <code> PlTerm *  Pl_Rd_Callable(PlTerm term, int *  func, int *  arity); </code> 
      @param func a direct only {@link java.nio.IntBuffer}
      @param arity a direct only {@link java.nio.IntBuffer}   */
  public static PointerBuffer Pl_Rd_Callable(long term, IntBuffer func, IntBuffer arity)  {

    if (!Buffers.isDirect(func))
      throw new RuntimeException("Argument \"func\" is not a direct buffer");
    if (!Buffers.isDirect(arity))
      throw new RuntimeException("Argument \"arity\" is not a direct buffer");
    final ByteBuffer _res;
    _res = Pl_Rd_Callable0(term, func, Buffers.getDirectBufferByteOffset(func), arity, Buffers.getDirectBufferByteOffset(arity));
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> PlTerm *  Pl_Rd_Callable(PlTerm term, int *  func, int *  arity); </code> 
      @param func a direct only {@link java.nio.IntBuffer}
      @param arity a direct only {@link java.nio.IntBuffer}   */
  private static native ByteBuffer Pl_Rd_Callable0(long term, Object func, int func_byte_offset, Object arity, int arity_byte_offset);

  /** Interface to C language function: <br> <code> PlTerm *  Pl_Rd_Callable_Check(PlTerm term, int *  func, int *  arity); </code> 
      @param func a direct only {@link java.nio.IntBuffer}
      @param arity a direct only {@link java.nio.IntBuffer}   */
  public static PointerBuffer Pl_Rd_Callable_Check(long term, IntBuffer func, IntBuffer arity)  {

    if (!Buffers.isDirect(func))
      throw new RuntimeException("Argument \"func\" is not a direct buffer");
    if (!Buffers.isDirect(arity))
      throw new RuntimeException("Argument \"arity\" is not a direct buffer");
    final ByteBuffer _res;
    _res = Pl_Rd_Callable_Check0(term, func, Buffers.getDirectBufferByteOffset(func), arity, Buffers.getDirectBufferByteOffset(arity));
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> PlTerm *  Pl_Rd_Callable_Check(PlTerm term, int *  func, int *  arity); </code> 
      @param func a direct only {@link java.nio.IntBuffer}
      @param arity a direct only {@link java.nio.IntBuffer}   */
  private static native ByteBuffer Pl_Rd_Callable_Check0(long term, Object func, int func_byte_offset, Object arity, int arity_byte_offset);

  /** Interface to C language function: <br> <code> int Pl_Rd_Char(PlTerm term); </code>    */
  public static native int Pl_Rd_Char(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_Char_Check(PlTerm term); </code>    */
  public static native int Pl_Rd_Char_Check(long term);

  /** Interface to C language function: <br> <code> char *  Pl_Rd_Chars(PlTerm term); </code>    */
  public static native String Pl_Rd_Chars(long term);

  /** Interface to C language function: <br> <code> char *  Pl_Rd_Chars_Check(PlTerm term); </code>    */
  public static native String Pl_Rd_Chars_Check(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_Chars_Str(PlTerm term, char *  str); </code> 
      @param str a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static int Pl_Rd_Chars_Str(long term, ByteBuffer str)  {

    final boolean str_is_direct = Buffers.isDirect(str);
        return Pl_Rd_Chars_Str1(term, str_is_direct ? str : Buffers.getArray(str), str_is_direct ? Buffers.getDirectBufferByteOffset(str) : Buffers.getIndirectBufferByteOffset(str), str_is_direct);
  }

  /** Entry point to C language function: <code> int Pl_Rd_Chars_Str(PlTerm term, char *  str); </code> 
      @param str a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native int Pl_Rd_Chars_Str1(long term, Object str, int str_byte_offset, boolean str_is_direct);

  /** Interface to C language function: <br> <code> int Pl_Rd_Chars_Str(PlTerm term, char *  str); </code>    */
  public static int Pl_Rd_Chars_Str(long term, byte[] str, int str_offset)  {

    if(str != null && str.length <= str_offset)
      throw new RuntimeException("array offset argument \"str_offset\" (" + str_offset + ") equals or exceeds array length (" + str.length + ")");
        return Pl_Rd_Chars_Str1(term, str, str_offset, false);
  }

  /** Interface to C language function: <br> <code> int Pl_Rd_Chars_Str_Check(PlTerm term, char *  str); </code> 
      @param str a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static int Pl_Rd_Chars_Str_Check(long term, ByteBuffer str)  {

    final boolean str_is_direct = Buffers.isDirect(str);
        return Pl_Rd_Chars_Str_Check1(term, str_is_direct ? str : Buffers.getArray(str), str_is_direct ? Buffers.getDirectBufferByteOffset(str) : Buffers.getIndirectBufferByteOffset(str), str_is_direct);
  }

  /** Entry point to C language function: <code> int Pl_Rd_Chars_Str_Check(PlTerm term, char *  str); </code> 
      @param str a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native int Pl_Rd_Chars_Str_Check1(long term, Object str, int str_byte_offset, boolean str_is_direct);

  /** Interface to C language function: <br> <code> int Pl_Rd_Chars_Str_Check(PlTerm term, char *  str); </code>    */
  public static int Pl_Rd_Chars_Str_Check(long term, byte[] str, int str_offset)  {

    if(str != null && str.length <= str_offset)
      throw new RuntimeException("array offset argument \"str_offset\" (" + str_offset + ") equals or exceeds array length (" + str.length + ")");
        return Pl_Rd_Chars_Str_Check1(term, str, str_offset, false);
  }

  /** Interface to C language function: <br> <code> int Pl_Rd_Code(PlTerm term); </code>    */
  public static native int Pl_Rd_Code(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_Code_Check(PlTerm term); </code>    */
  public static native int Pl_Rd_Code_Check(long term);

  /** Interface to C language function: <br> <code> char *  Pl_Rd_Codes(PlTerm term); </code>    */
  public static native String Pl_Rd_Codes(long term);

  /** Interface to C language function: <br> <code> char *  Pl_Rd_Codes_Check(PlTerm term); </code>    */
  public static native String Pl_Rd_Codes_Check(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_Codes_Str(PlTerm term, char *  str); </code> 
      @param str a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static int Pl_Rd_Codes_Str(long term, ByteBuffer str)  {

    final boolean str_is_direct = Buffers.isDirect(str);
        return Pl_Rd_Codes_Str1(term, str_is_direct ? str : Buffers.getArray(str), str_is_direct ? Buffers.getDirectBufferByteOffset(str) : Buffers.getIndirectBufferByteOffset(str), str_is_direct);
  }

  /** Entry point to C language function: <code> int Pl_Rd_Codes_Str(PlTerm term, char *  str); </code> 
      @param str a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native int Pl_Rd_Codes_Str1(long term, Object str, int str_byte_offset, boolean str_is_direct);

  /** Interface to C language function: <br> <code> int Pl_Rd_Codes_Str(PlTerm term, char *  str); </code>    */
  public static int Pl_Rd_Codes_Str(long term, byte[] str, int str_offset)  {

    if(str != null && str.length <= str_offset)
      throw new RuntimeException("array offset argument \"str_offset\" (" + str_offset + ") equals or exceeds array length (" + str.length + ")");
        return Pl_Rd_Codes_Str1(term, str, str_offset, false);
  }

  /** Interface to C language function: <br> <code> int Pl_Rd_Codes_Str_Check(PlTerm term, char *  str); </code> 
      @param str a direct or array-backed {@link java.nio.ByteBuffer}   */
  public static int Pl_Rd_Codes_Str_Check(long term, ByteBuffer str)  {

    final boolean str_is_direct = Buffers.isDirect(str);
        return Pl_Rd_Codes_Str_Check1(term, str_is_direct ? str : Buffers.getArray(str), str_is_direct ? Buffers.getDirectBufferByteOffset(str) : Buffers.getIndirectBufferByteOffset(str), str_is_direct);
  }

  /** Entry point to C language function: <code> int Pl_Rd_Codes_Str_Check(PlTerm term, char *  str); </code> 
      @param str a direct or array-backed {@link java.nio.ByteBuffer}   */
  private static native int Pl_Rd_Codes_Str_Check1(long term, Object str, int str_byte_offset, boolean str_is_direct);

  /** Interface to C language function: <br> <code> int Pl_Rd_Codes_Str_Check(PlTerm term, char *  str); </code>    */
  public static int Pl_Rd_Codes_Str_Check(long term, byte[] str, int str_offset)  {

    if(str != null && str.length <= str_offset)
      throw new RuntimeException("array offset argument \"str_offset\" (" + str_offset + ") equals or exceeds array length (" + str.length + ")");
        return Pl_Rd_Codes_Str_Check1(term, str, str_offset, false);
  }

  /** Interface to C language function: <br> <code> PlTerm *  Pl_Rd_Compound(PlTerm term, int *  func, int *  arity); </code> 
      @param func a direct only {@link java.nio.IntBuffer}
      @param arity a direct only {@link java.nio.IntBuffer}   */
  public static PointerBuffer Pl_Rd_Compound(long term, IntBuffer func, IntBuffer arity)  {

    if (!Buffers.isDirect(func))
      throw new RuntimeException("Argument \"func\" is not a direct buffer");
    if (!Buffers.isDirect(arity))
      throw new RuntimeException("Argument \"arity\" is not a direct buffer");
    final ByteBuffer _res;
    _res = Pl_Rd_Compound0(term, func, Buffers.getDirectBufferByteOffset(func), arity, Buffers.getDirectBufferByteOffset(arity));
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> PlTerm *  Pl_Rd_Compound(PlTerm term, int *  func, int *  arity); </code> 
      @param func a direct only {@link java.nio.IntBuffer}
      @param arity a direct only {@link java.nio.IntBuffer}   */
  private static native ByteBuffer Pl_Rd_Compound0(long term, Object func, int func_byte_offset, Object arity, int arity_byte_offset);

  /** Interface to C language function: <br> <code> PlTerm *  Pl_Rd_Compound_Check(PlTerm term, int *  func, int *  arity); </code> 
      @param func a direct only {@link java.nio.IntBuffer}
      @param arity a direct only {@link java.nio.IntBuffer}   */
  public static PointerBuffer Pl_Rd_Compound_Check(long term, IntBuffer func, IntBuffer arity)  {

    if (!Buffers.isDirect(func))
      throw new RuntimeException("Argument \"func\" is not a direct buffer");
    if (!Buffers.isDirect(arity))
      throw new RuntimeException("Argument \"arity\" is not a direct buffer");
    final ByteBuffer _res;
    _res = Pl_Rd_Compound_Check0(term, func, Buffers.getDirectBufferByteOffset(func), arity, Buffers.getDirectBufferByteOffset(arity));
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> PlTerm *  Pl_Rd_Compound_Check(PlTerm term, int *  func, int *  arity); </code> 
      @param func a direct only {@link java.nio.IntBuffer}
      @param arity a direct only {@link java.nio.IntBuffer}   */
  private static native ByteBuffer Pl_Rd_Compound_Check0(long term, Object func, int func_byte_offset, Object arity, int arity_byte_offset);

  /** Interface to C language function: <br> <code> double Pl_Rd_Float(PlTerm term); </code>    */
  public static native double Pl_Rd_Float(long term);

  /** Interface to C language function: <br> <code> double Pl_Rd_Float_Check(PlTerm term); </code>    */
  public static native double Pl_Rd_Float_Check(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_In_Byte(PlTerm term); </code>    */
  public static native int Pl_Rd_In_Byte(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_In_Byte_Check(PlTerm term); </code>    */
  public static native int Pl_Rd_In_Byte_Check(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_In_Char(PlTerm term); </code>    */
  public static native int Pl_Rd_In_Char(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_In_Char_Check(PlTerm term); </code>    */
  public static native int Pl_Rd_In_Char_Check(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_In_Code(PlTerm term); </code>    */
  public static native int Pl_Rd_In_Code(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_In_Code_Check(PlTerm term); </code>    */
  public static native int Pl_Rd_In_Code_Check(long term);

  /** Interface to C language function: <br> <code> PlLong Pl_Rd_Integer(PlTerm term); </code>    */
  public static native long Pl_Rd_Integer(long term);

  /** Interface to C language function: <br> <code> PlLong Pl_Rd_Integer_Check(PlTerm term); </code>    */
  public static native long Pl_Rd_Integer_Check(long term);

  /** Interface to C language function: <br> <code> PlTerm *  Pl_Rd_List(PlTerm term); </code>    */
  public static PointerBuffer Pl_Rd_List(long term)  {

    final ByteBuffer _res;
    _res = Pl_Rd_List1(term);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> PlTerm *  Pl_Rd_List(PlTerm term); </code>    */
  private static native ByteBuffer Pl_Rd_List1(long term);

  /** Interface to C language function: <br> <code> PlTerm *  Pl_Rd_List_Check(PlTerm term); </code>    */
  public static PointerBuffer Pl_Rd_List_Check(long term)  {

    final ByteBuffer _res;
    _res = Pl_Rd_List_Check1(term);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> PlTerm *  Pl_Rd_List_Check(PlTerm term); </code>    */
  private static native ByteBuffer Pl_Rd_List_Check1(long term);

  /** Interface to C language function: <br> <code> double Pl_Rd_Number(PlTerm term); </code>    */
  public static native double Pl_Rd_Number(long term);

  /** Interface to C language function: <br> <code> double Pl_Rd_Number_Check(PlTerm term); </code>    */
  public static native double Pl_Rd_Number_Check(long term);

  /** Interface to C language function: <br> <code> PlLong Pl_Rd_Positive(PlTerm term); </code>    */
  public static native long Pl_Rd_Positive(long term);

  /** Interface to C language function: <br> <code> PlLong Pl_Rd_Positive_Check(PlTerm term); </code>    */
  public static native long Pl_Rd_Positive_Check(long term);

  /** Interface to C language function: <br> <code> int Pl_Rd_Proper_List(PlTerm term, PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static int Pl_Rd_Proper_List(long term, PointerBuffer arg)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Rd_Proper_List1(term, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct);
  }

  /** Entry point to C language function: <code> int Pl_Rd_Proper_List(PlTerm term, PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native int Pl_Rd_Proper_List1(long term, Object arg, int arg_byte_offset, boolean arg_is_direct);

  /** Interface to C language function: <br> <code> int Pl_Rd_Proper_List_Check(PlTerm term, PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static int Pl_Rd_Proper_List_Check(long term, PointerBuffer arg)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Rd_Proper_List_Check1(term, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct);
  }

  /** Entry point to C language function: <code> int Pl_Rd_Proper_List_Check(PlTerm term, PlTerm *  arg); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native int Pl_Rd_Proper_List_Check1(long term, Object arg, int arg_byte_offset, boolean arg_is_direct);

  /** Interface to C language function: <br> <code> char *  Pl_Rd_String(PlTerm term); </code>    */
  public static native String Pl_Rd_String(long term);

  /** Interface to C language function: <br> <code> char *  Pl_Rd_String_Check(PlTerm term); </code>    */
  public static native String Pl_Rd_String_Check(long term);

  /** Interface to C language function: <br> <code> PlTerm Pl_Read_From_String(const char *  str); </code>    */
  public static native long Pl_Read_From_String(String str);

  /** Interface to C language function: <br> <code> void Pl_Reset_Prolog(void); </code>    */
  public static native void Pl_Reset_Prolog();

  /** Interface to C language function: <br> <code> void Pl_Set_C_Bip_Name(const char *  functor, int arity); </code>    */
  public static native void Pl_Set_C_Bip_Name(String functor, int arity);

  /** Interface to C language function: <br> <code> int Pl_Start_Prolog(int argc, char *  *  argv); </code> 
      @param argv a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static int Pl_Start_Prolog(int argc, PointerBuffer argv)  {

    final boolean argv_is_direct = Buffers.isDirect(argv);
        return Pl_Start_Prolog1(argc, argv_is_direct ? ( argv != null ? argv.getBuffer() : null ) : Buffers.getArray(argv), argv_is_direct ? Buffers.getDirectBufferByteOffset(argv) : Buffers.getIndirectBufferByteOffset(argv), argv_is_direct);
  }

  /** Entry point to C language function: <code> int Pl_Start_Prolog(int argc, char *  *  argv); </code> 
      @param argv a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native int Pl_Start_Prolog1(int argc, Object argv, int argv_byte_offset, boolean argv_is_direct);

  /** Interface to C language function: <br> <code> void Pl_Stop_Prolog(void); </code>    */
  public static native void Pl_Stop_Prolog();

  /** Interface to C language function: <br> <code> PlLong Pl_Term_Compare(PlTerm term1, PlTerm term2); </code>    */
  public static native long Pl_Term_Compare(long term1, long term2);

  /** Interface to C language function: <br> <code> int Pl_Term_Size(PlTerm term); </code>    */
  public static native int Pl_Term_Size(long term);

  /** Interface to C language function: <br> <code> void Pl_Throw(PlTerm ball); </code>    */
  public static native void Pl_Throw(long ball);

  /** Interface to C language function: <br> <code> PlBool Pl_Try_Execute_Top_Level(void); </code>    */
  public static native boolean Pl_Try_Execute_Top_Level();

  /** Interface to C language function: <br> <code> int Pl_Type_Of_Term(PlTerm term); </code>    */
  public static native int Pl_Type_Of_Term(long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Atom(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Atom(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Atom_Check(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Atom_Check(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Boolean(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Boolean(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Boolean_Check(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Boolean_Check(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Byte(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Byte(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Byte_Check(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Byte_Check(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Callable(int func, int arity, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean Pl_Un_Callable(int func, int arity, PointerBuffer arg, long term)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Un_Callable1(func, arity, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct, term);
  }

  /** Entry point to C language function: <code> PlBool Pl_Un_Callable(int func, int arity, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native boolean Pl_Un_Callable1(int func, int arity, Object arg, int arg_byte_offset, boolean arg_is_direct, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Callable_Check(int func, int arity, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean Pl_Un_Callable_Check(int func, int arity, PointerBuffer arg, long term)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Un_Callable_Check1(func, arity, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct, term);
  }

  /** Entry point to C language function: <code> PlBool Pl_Un_Callable_Check(int func, int arity, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native boolean Pl_Un_Callable_Check1(int func, int arity, Object arg, int arg_byte_offset, boolean arg_is_direct, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Char(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Char(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Char_Check(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Char_Check(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Chars(const char *  value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Chars(String value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Chars_Check(const char *  value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Chars_Check(String value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Code(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Code(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Code_Check(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Code_Check(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Codes(const char *  value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Codes(String value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Codes_Check(const char *  value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Codes_Check(String value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Compound(int func, int arity, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean Pl_Un_Compound(int func, int arity, PointerBuffer arg, long term)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Un_Compound1(func, arity, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct, term);
  }

  /** Entry point to C language function: <code> PlBool Pl_Un_Compound(int func, int arity, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native boolean Pl_Un_Compound1(int func, int arity, Object arg, int arg_byte_offset, boolean arg_is_direct, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Compound_Check(int func, int arity, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean Pl_Un_Compound_Check(int func, int arity, PointerBuffer arg, long term)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Un_Compound_Check1(func, arity, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct, term);
  }

  /** Entry point to C language function: <code> PlBool Pl_Un_Compound_Check(int func, int arity, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native boolean Pl_Un_Compound_Check1(int func, int arity, Object arg, int arg_byte_offset, boolean arg_is_direct, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Float(double value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Float(double value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Float_Check(double value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Float_Check(double value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_In_Byte(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_In_Byte(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_In_Byte_Check(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_In_Byte_Check(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_In_Char(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_In_Char(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_In_Char_Check(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_In_Char_Check(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_In_Code(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_In_Code(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_In_Code_Check(int value, PlTerm term); </code>    */
  public static native boolean Pl_Un_In_Code_Check(int value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Integer(PlLong value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Integer(long value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Integer_Check(PlLong value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Integer_Check(long value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_List(PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean Pl_Un_List(PointerBuffer arg, long term)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Un_List1(arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct, term);
  }

  /** Entry point to C language function: <code> PlBool Pl_Un_List(PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native boolean Pl_Un_List1(Object arg, int arg_byte_offset, boolean arg_is_direct, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_List_Check(PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean Pl_Un_List_Check(PointerBuffer arg, long term)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Un_List_Check1(arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct, term);
  }

  /** Entry point to C language function: <code> PlBool Pl_Un_List_Check(PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native boolean Pl_Un_List_Check1(Object arg, int arg_byte_offset, boolean arg_is_direct, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Number(double value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Number(double value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Number_Check(double value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Number_Check(double value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Positive(PlLong value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Positive(long value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Positive_Check(PlLong value, PlTerm term); </code>    */
  public static native boolean Pl_Un_Positive_Check(long value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Proper_List(int n, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean Pl_Un_Proper_List(int n, PointerBuffer arg, long term)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Un_Proper_List1(n, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct, term);
  }

  /** Entry point to C language function: <code> PlBool Pl_Un_Proper_List(int n, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native boolean Pl_Un_Proper_List1(int n, Object arg, int arg_byte_offset, boolean arg_is_direct, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Proper_List_Check(int n, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public static boolean Pl_Un_Proper_List_Check(int n, PointerBuffer arg, long term)  {

    final boolean arg_is_direct = Buffers.isDirect(arg);
        return Pl_Un_Proper_List_Check1(n, arg_is_direct ? ( arg != null ? arg.getBuffer() : null ) : Buffers.getArray(arg), arg_is_direct ? Buffers.getDirectBufferByteOffset(arg) : Buffers.getIndirectBufferByteOffset(arg), arg_is_direct, term);
  }

  /** Entry point to C language function: <code> PlBool Pl_Un_Proper_List_Check(int n, PlTerm *  arg, PlTerm term); </code> 
      @param arg a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private static native boolean Pl_Un_Proper_List_Check1(int n, Object arg, int arg_byte_offset, boolean arg_is_direct, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_String(const char *  value, PlTerm term); </code>    */
  public static native boolean Pl_Un_String(String value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_String_Check(const char *  value, PlTerm term); </code>    */
  public static native boolean Pl_Un_String_Check(String value, long term);

  /** Interface to C language function: <br> <code> PlBool Pl_Un_Term(PlTerm term1, PlTerm term2); </code>    */
  public static native boolean Pl_Un_Term(long term1, long term2);

  /** Interface to C language function: <br> <code> PlBool Pl_Unif(PlTerm term1, PlTerm term2); </code>    */
  public static native boolean Pl_Unif(long term1, long term2);

  /** Interface to C language function: <br> <code> PlBool Pl_Unif_With_Occurs_Check(PlTerm term1, PlTerm term2); </code>    */
  public static native boolean Pl_Unif_With_Occurs_Check(long term1, long term2);

  /** Interface to C language function: <br> <code> void Pl_Unset_C_Bip_Name(void); </code>    */
  public static native void Pl_Unset_C_Bip_Name();

  /** Interface to C language function: <br> <code> void Pl_Write(PlTerm term); </code>    */
  public static native void Pl_Write(long term);

  /** Interface to C language function: <br> <code> char *  Pl_Write_Canonical_To_String(PlTerm term); </code>    */
  public static native String Pl_Write_Canonical_To_String(long term);

  /** Interface to C language function: <br> <code> char *  Pl_Write_To_String(PlTerm term); </code>    */
  public static native String Pl_Write_To_String(long term);

  /** Interface to C language function: <br> <code> char *  Pl_Writeq_To_String(PlTerm term); </code>    */
  public static native String Pl_Writeq_To_String(long term);


} // end of class JGProlog
